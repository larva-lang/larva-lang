!<<

import (
    "runtime"
    "strings"
    "fmt"
    "reflect"
    "errors"
)

/*
tb信息格式：

Traceback:
  File '文件', line 行号, in 函数或方法名或<module> //larva代码的tb信息
  File '文件', line 行号                            //非larva代码的tb信息
  ......
异常类型名: 抛出的异常的字符串描述

其中堆栈信息的方向是从栈底开始显示，即每行信息是下一行的调用者

非larva代码（一般是native go代码）的tb信息不显示具体函数或方法名是因为go的内联优化有可能导致runtime.Caller返回的pc是内联后的上层函数的代码地址，
不够准确，而如果使用-gcflags "-l"关闭内联又会有较大性能损耗
*/

func lar_exc_create_catched_throwable(t lar_intf_@<<Throwable>>, skip int) *lar_gcls_inst_@<<Catched>>_1_lar_intf_@<<Throwable>> {
    var tb_line_list []string
    if t != nil {
        var t_type_name string
        lri, ok := t.(lar_reflect_intf)
        if ok {
            t_type_name = lar_str_to_go_str(lri.lar_reflect_type_name())
        } else {
            t_type_name = fmt.Sprintf("<GoType %s>", reflect.TypeOf(t).String())
        }
        tb_line_list = append(tb_line_list, t_type_name + ": " + lar_str_to_go_str(t.lar_method_str()))
    }
    for i := skip; true; i ++ {
        pc, file, line, ok := runtime.Caller(i)
        if !ok {
            break
        }
        if file == "<autogenerated>" || strings.HasPrefix(file, lar_util_GOROOT_path) {
            //忽略自动生成文件和go内建库的tb
            continue
        }
        func_name := runtime.FuncForPC(pc).Name()
        in_init_mod_func := false
        func_name_parts := strings.Split(func_name, ".")
        if len(func_name_parts) == 2 {
            fn := func_name_parts[1]
            if fn == "lar_booter_start_prog" || fn == "lar_booter_start_co" {
                //追溯到了程序或协程的入口，停止
                break
            }
            if strings.HasPrefix(fn, "lar_env_init_mod_") {
                in_init_mod_func = true
            }
        }
        file, line, func_name, ok = lar_util_convert_go_tb_to_lar_tb(file, line, func_name)
        if ok {
            if in_init_mod_func && func_name != "<module>" {
                //追溯到了模块初始化代码，且不是larva层面的代码行，则停止
                break
            }
            tb_line := fmt.Sprintf("  File '%s', line %d", file, line)
            if func_name != "" {
                tb_line += ", in " + func_name
            }
            if len(tb_line_list) == 0 || tb_line_list[len(tb_line_list) - 1] != tb_line {
                tb_line_list = append(tb_line_list, tb_line)
            }
        }
    }
    tb_line_list = append(tb_line_list, "Traceback:")
    //上面是反着写info的，reverse一下
    tb_line_count := len(tb_line_list)
    for i := 0; i < tb_line_count / 2; i ++ {
        tb_line_list[i], tb_line_list[tb_line_count - 1 - i] = tb_line_list[tb_line_count - 1 - i], tb_line_list[i]
    }

    tb := lar_str_from_go_str(strings.Join(tb_line_list, "\n"))
    return lar_new_obj_lar_gcls_inst_@<<Catched>>_1_lar_intf_@<<Throwable>>(t, tb)
}

//转换go的内置panic对象为larva的异常
func lar_exc_convert_go_recovered_to_lar_throwed(r interface{}) *lar_gcls_inst_@<<Catched>>_1_lar_intf_@<<Throwable>> {
    const skip int = 5

    //对于可以拿到具体类型的，直接转
    if _, ok := r.(*runtime.TypeAssertionError); ok {
        return lar_exc_create_catched_throwable(lar_new_obj_lar_cls_@<<CastError>>(), skip)
    }

    //go没有暴露一些常见panic的数据类型，用反射检查，但注意这个检查可能随着go的版本升级而无效
    tp := reflect.TypeOf(r)
    if tp.PkgPath() == "runtime" && tp.Name() == "errorString" {
        e, ok := r.(error)
        if ok {
            switch e.Error() {
            case "runtime error: index out of range":
                t := lar_new_obj_lar_cls_@<<IndexError>>(0)
                t.m_has_idx = false
                return lar_exc_create_catched_throwable(t, skip)
            case "runtime error: slice bounds out of range":
                t := lar_new_obj_lar_cls_@<<RangeError>>(0, 0, 0)
                t.m_has_range_info = false
                return lar_exc_create_catched_throwable(t, skip)
            }
        }
    }

    return nil
}

//捕获的异常转换为go的error
func (this *lar_gcls_inst_@<<Catched>>_1_lar_intf_@<<Throwable>>) lar_go_method_to_go_err() error {
    //若本身包含go的异常，直接返回即可
    ge, ok := this.m_t.(lar_intf_@<<GoErrorPorter>>)
    if ok {
        return ge.lar_method_go_err().err
    }
    //提取信息，转为go的error字符串
    var t_type_name string
    lri, ok := this.m_t.(lar_reflect_intf)
    if ok {
        t_type_name = lar_str_to_go_str(lri.lar_reflect_type_name())
    } else {
        t_type_name = fmt.Sprintf("<GoType %s>", reflect.TypeOf(this.m_t).String())
    }
    return errors.New("[Larva throwed]" + t_type_name + ": " + lar_str_to_go_str(this.m_t.lar_method_str()))
}

func lar_go_func_@<<throw_go_err>>(err error) {
    lar_func_@<<throw>>(&lar_cls_@<<GoError>>{
        err: err,
    })
}

//用于反向port时候的defer
func lar_go_func_@<<catch_go_err>>(err_ptr *error) {
    c := lar_func_@<<catch_base>>(recover())
    if c != nil {
        *err_ptr = c.lar_go_method_to_go_err()
    }
}

!>>
