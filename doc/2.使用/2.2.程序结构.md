# **程序结构**

本节用于说明Larva的程序组织结构的设计和编译过程

## **标准库和用户库**

Larva的代码在本地磁盘只能存在于两个目录下，称为标准库和用户库。
标准库是Larva本身的lib目录，存放Larva内置的模块；用户库是用户指定的一个目录，存放用户自行开发的模块

由于标准库代码一般是不会被修改的，因此实际上可以说代码都在用户库目录下，用户库目录的指定方式见‘2.1.环境需求’

用户库目录必须存在，编译器每次启动会做环境检查

## **模块**

模块是组成Larva程序的基本单元，每个模块包含实现它的代码，这些代码定义了模块级别的程序元素（后简称‘模块元素’）

Larva的模块分为两类：
1. 非git模块，一般用于标准库或本地代码
    * 模块名格式为`NAME[[/NAME]...]`，即斜线链接的多级目录形式，其中`NAME`必须是一个合法的标识符（标识符定义参考‘3.2.词法元素’）

    * 例如：标准库中的模块`__builtins`、`os`、`io/bufio`等

1. git模块，一般用于普通项目的开发
    * 存储于其他git项目，在Larva代码中可直接导入，编译器会自动获取或根据选项来更新git项目，git模块将存储于用户库目录下

    * 模块名格式为`"GIT_REPO_ADDR"/NAME[[/NAME]...]`，其中双引号括起来的字符串GIT_REPO_ADDR是项目的git地址，格式为`HOST/USER/REPO`，
    后面至少要跟一层`NAME`，`NAME`的含义同上述非git模块的模块名中的`NAME`

    * 例如：`"github.com/x/y"/a/b`

模块的存储方式是在标准库或用户库目录下的单层或多层的子目录
* 非git模块以其模块名表示的目录结构存放在标准库或用户库下
    * 例如：标准库模块`io/bufio`对应标准库目录下的子目录`io/bufio`

* git模块存放在用户库目录下，目录结构使用git项目地址和在项目之下的模块名用斜线连接起来的结果，简单说就是去掉模块名中git项目地址两侧的双引号
    * 例如：默认情况下，模块`"github.com/x/y"/a/b`对应目录`~/larva/github.com/x/y/a/b`

模块的导入语法和具体使用在这里不做说明，请参考‘3.3.模块导入’，Larva在编译过程中查找模块的策略请参考‘2.3.编译执行’

模块目录下存放Larva的源代码文件，后缀名统一为‘.lar’（后简称‘lar文件’）

编译器以模块为单位进行处理和编译工作：
1. 扫描目录下所有lar文件，读入内存，进行预编译和编译工作
1. 在输出阶段，一个模块的lar文件分别被输出为一个对应的Golang源码文件，即后缀名为‘.go’（后简称‘go文件’）
* lar文件必须是一个常规文件，或到其他常规文件的软连接，而不能是目录、管道之类，编译器会检查；
编译器会忽略模块目录下的其他后缀名的文件，这意味着开发者可以自由增加例如Markdown文档之类的文件，当然也可以有子目录

如上所述，模块可以是多级目录的，但是不同目录的模块之间是独立的，没有程序组织上的特殊联系，只有其相对位置的联系，体现在相对路径导入上
* 例如，`a/b/c`和`a/b`对于编译器来说，是两个独立模块，它们没有包含、从属或父子之类的关系，前者放在后者内部仅是因为有一定的逻辑关系，
它们语法上的唯一联系是后者的代码中可以通过`import ./c`来做相对路径导入，
而编译器解析相对路径导入也仅仅是用当前模块名`a/b`替换`.`从而生成`a/b/c`而已；在前者的代码中也可通过`import ../../b`来导入上层目录，
编译器的做法是在前者基础上去掉尾部两层然后加上`b`，相对路径导入的具体信息请参考‘3.3.模块导入’

    * *Note*：若通过类似模块名`"github.com/larva-lang/larva-lang"/lib/os`的形式来导入Larva自己的标准库代码，
    对于编译器来说这就是一个普通的git项目，不会对其做识别和特殊处理，换句话说，这时候导入的模块和直接通过`os`名字导入的os模块是两个独立的模块，
    只是代码一模一样而已

若模块名中某一个`NAME`是双下划线开头，则说明这一级模块是私有模块，关于私有模块的导入规则请参考‘3.3.模块导入’

模块的组织有如下限制：
1. 标准库下第一级模块的名字必须是合法的标识符，且不能含有私有模块的前导双下划线之外的其他下划线
1. 用户库下第一级模块的名字若含字符‘.’，则视为git模块的存储目录（即这个名字是git的host名），若不含字符‘.’则必须是一个合法标识符，
且不能和标准库的任意一个第一级模块名冲突
* *Note*：由于标准库第一级模块名不会含有前导双下划线之外的下划线，因此如果在用户库下开发非git模块，第一级名字用带下划线的即可避免冲突，
虽然如此，还是建议大家在用户库下开发的代码都采用git来统一维护

从模块元素的角度讲，每个模块无论分多少文件，在逻辑上是一个整体的，它包含四类元素：
1. 类（class）
2. 接口（interface）
3. 全局变量
4. 函数

各元素的含义和定义语法等内容，请参考‘3.语法’下对应文档

任何一个Larva程序都由若干模块组成，且一定包含若干特殊模块：

1. 标准库目录下的几个私有模块，其中需要注意的是`__builtins`，存放了内建类、函数、接口等，其余几个属于内部实现所需的模块，对外无感知
1. 编译命令指定的主模块

## **临时工作目录**

Larva在编译一个程序的时候会有一些临时性的输出，这些输出会放在临时工作目录下，临时工作目录的指定方式见‘2.1.环境需求’

临时工作目录的内容包括生成的Golang代码、可执行程序等，在编译结束后不会被删除，方便查问题

每次编译开始时编译器都会清理当前处理的程序对应的一些临时路径，编译过程中也会做一些写操作，
因此若存在并发执行的Larva编译过程的可能，不同编译任务最好不要使用同一个临时目录

Larva会在临时工作目录下创建一些隐藏目录用于编译时的临时输出或中间数据输出：
* 临时输出目录：`.larva_tmp_out`，用于输出编译后的Golang代码

## **编译过程**

1. 准备阶段
    * 初始化编译器环境
    * 解析编译命令和选项
    * 预编译标准库中的几个私有模块（含内建模块`__builtins`）并加入模块集合

2. 预编译阶段
    * 从编译命令和选项指定的主模块开始，将其预编译并加入模块集合
    * 分析当前模块集合中的模块的依赖模块，若某依赖模块还没有在模块集合中，则预编译它并加入集合，反复进行这一步直到没有任何未加入的依赖模块，
    此时即收集到了目标程序所需要的所有模块集合，且都通过预编译的检查
    * 在这个过程中，若遇到了git模块：
        * 若对应的git项目在本地不存在，则自动执行`git clone`获取
        * 若对应的git项目在本地已存在则根据编译选项选择是否执行`git pull`更新
        * 最后进行实际的读取源代码并预编译的流程
    * *Note*：预编译会做完整的词法分析，解析出模块中的元素，并执行一些简单的语法检查等，但并不会编译每个元素的具体实现（表达式、语句块等），
    可以认为预编译只是分析出了各个元素的声明

3. 编译阶段
    * 编译阶段会对模块集合中所有模块做正式的语法分析、检查，并生成抽象语法树（AST）
    * 主模块必须包含程序入口main函数，main函数的定义必须是`public void main()`，函数相关内容请参考‘3.语法’章节

4. 输出阶段
    * 在临时输出目录下建立程序的Golang代码输出目录（下简称‘tmp_out目录’），其相对于临时输出目录的结构和主模块在标准库或用户库下的目录结构相同
        * 例如：默认情况下，模块`"github.com/x/y"/a/b`的tmp_out目录是`~/tmp/.larva_tmp_out/github.com/x/y/a/b`
    * 输出目标Golang代码到tmp_out目录下
    * 设置相关环境变量并调用go build对输出的目标代码进行Golang的编译，在tmp_out目录下生成可执行文件
    * 根据编译时指定的行为，对最终生成的可执行文件选择合适的操作，例如拷贝到指定文件或直接执行
