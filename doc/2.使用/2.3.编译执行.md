# **编译执行**

本节将通过一个简单的‘hello world’示例来说明使用Larva开发、编译和执行的过程

## **环境准备**

根据前述环境需求准备好运行平台，并安装、配置好Python2、Golang、Git的开发环境，其启动命令`python`、`go`、`git`所在目录均需加入环境变量PATH，
即保证可直接通过命令来执行，因为编译器或Larva的工具脚本会通过当前环境调用它

## **安装Larva**

从Larva项目地址通过git clone或直接下载的方式将整个项目下载至本地，可存储在任意位置，为文档描述方便起见，假设项目目录为`~/larva-lang`

用户库目录和临时工作目录按照之前文档的介绍自行设置，为描述方便起见，我们在之后的文档的说明中统一采用默认路径

Larva的bin目录，即`~/larva-lang/bin`下存放的是实现各种功能的可执行脚本，为方便起见，可将这个目录设置到环境变量`PATH`中，以下默认已经这么做了。
各脚本的用法可以直接运行查看帮助信息

## **开发程序**

如前所述，一个Larva程序由标准库的必要模块（几个私有的模块）、主模块和其所直接或间接依赖的其他模块组成，
因此开发一个程序本质就是就是开发必要模块，然后和已有的模块组合编译的过程

以开发一个简单的`hello world`程序为例，这个程序本身需要一个主模块，我们将其命名为`hello_world`
1. 可以选择非git模块的形式，在用户库建立它的目录，假设为`~/larva-lang/ulib/hello_world`
1. 在主模块目录下建立代码文件开始开发，例如`~/larva-lang/ulib/hello_world/main.lar`
1. 编辑这个代码文件，录入代码：
    ```
    public void main()
    {
        println("hello world");
    }
    ```
    *Note*：代码的语法含义解释不在本节内容范围，只需要知道上述代码是一个打印出“hello world”的程序即可（严格说是这个程序的主模块）

## **编译执行**

1. 执行命令编译模块
    ```
    larvac -o ./hello_world -m hello_world
    ```
    或者通过目录名来指定模块
    ```
    larvac -o ./hello_world ~/larva-lang/ulib/hello_world/
    ```
    命令执行成功后，将在当前目录下生成文件`hello_world`，即输出的可执行文件

    * *Note*：如文件`./hello_world`已存在，则覆盖，不存在则新建；如它是一个目录，则会报错，即使用者自己保证输出可执行程序文件名的正确性
    * *Note*：如有需要，可进入临时输出目录查看生成的Golang代码，可看到生成了一个目录`~/larva-lang/tmp/.larva_tmp_out/hello_world`即程序的tmp_out目录，
    tmp_out目录下有两项：
        * 一个可执行程序`mod99B1_11_hello_world`，即编译结果，直接执行即可如期望打印出‘hello world’
            * 注：临时输出目录中的可执行程序的名字为模块的内部名字，其中`mod99B1`是模块的内部编号，不需要关心具体值
        * 一个目录‘src’，存放这个程序的Golang目标代码，包括两项：
            * 一个目录，程序的所有Larva模块的编译结果都在这个目录中，这个目录本身也是一个Golang的package，
            也就是说整个一个Larva程序会被编译为一个Golang的package，Larva级别的模块只是在编译过程做区分。这个Golang package会有一个引导函数，
            用于初始化程序环境并调用Larva的main函数的编译结果
            * 一个引导程序的go文件，即Golang程序的`package main`，内容很简单，直接调用上面说的引导函数来启动程序

1. 运行程序，直接执行`./hello_world`即可看到执行结果

这里为了描述清晰，将编译和执行过程分开成两个步骤，如果用命令`larva`代替`larvac`并去掉`-o`选项，则可对一个程序进行编译+执行的批处理操作，
在开发调试中会比较方便：
```
larva -m hello_world
```
或者
```
larva ~/larva-lang/ulib/hello_world/
```
为统一起见，在之后的文档中的类似命令一律采用`-m`选项指定模块全名的形式来描述

也可选择git模块的方式，例如上述例子，我们在git项目`github.com/a/b`中建立模块`hello_world`并做开发，提交代码后，则可直接执行：
```
larva -m '"github.com/a/b"/hello_world'
```
由于git模块的全名带有双引号，这里通过单引号来传递命令行参数，为方便起见，`larva`命令也允许`-m`后的git模块全名不写引号：
```
larva -m github.com/a/b/hello_world
```

## **模块查找流程**

如前所述，Larva在编译的时候从内建模块和主模块开始，逐步收集完成程序的模块集合并进行编译，在这个过程中，需要通过模块全名来找到其代码所在位置

* 若为非git模块，Larva会依次到标准库和用户库查找模块是否存在，由于Larva要求标准库和用户库第一级模块名不能有相同的，因此会找到唯一的一个模块，
或模块不存在

* 若为git模块，则直接去用户库查找
    * 若对应的git项目不存在，则会先执行`git clone`获取
    * 若对应的git项目已存在，且制定了编译选项`-u`，则会先执行`git pull`更新

* 模块全名和模块的目录结构的对应在‘2.2.程序结构’中已有说明

* 若最终找不到模块，则编译器报错退出
